#!/usr/bin/env python3

"""Investments distribution calculator"""

import argparse
import operator

from decimal import Decimal
from typing import List

import requests


class Actions:
    SHOW = "show"
    REBALANCE = "rebalance"

    ALL = [SHOW, REBALANCE]


class Currency:
    USD = "usd"
    RUB = "rub"


class CommissionSpec:
    def __init__(self, *, minimum, percent=None, per_share=None, maximum_percent=None):
        self.__minimum = Decimal(minimum)
        self.__percent = None if percent is None else Decimal(percent)
        self.__per_share = None if per_share is None else Decimal(per_share)
        self.__maximum_percent = None if maximum_percent is None else Decimal(maximum_percent)

    def calculate(self, shares, price):
        commissions = Decimal()

        if self.__percent is not None:
            commissions += shares * price * self.__percent / 100

        if self.__per_share is not None:
            commissions += shares * self.__per_share

        if self.__maximum_percent is not None:
            commissions = min(commissions, shares * price * self.__maximum_percent / 100)

        return max(self.__minimum, commissions)


class Holding:
    def __init__(self, name, weight, ticker=None, shares=None, holdings=None):
        if (ticker is not None) == bool(holdings):
            raise Error("Invalid holding {!r}: either ticket or group's holdings must be specified.", name)

        if (ticker is None) != (shares is None):
            raise Error("Invalid holding {!r}: ticker must be specified with shares.", name)

        if ticker is not None:
            name = "{} ({})".format(name, ticker)

        self.ticker = ticker
        self.name = name

        self.expected_weight = Decimal(weight) / 100
        self.weight = self.expected_weight

        if self.is_group:
            self.holdings = holdings
        else:
            self.current_shares = shares
            self.shares = shares
            self.commission = 0

            self.price = None

        self.current_value = None
        self.value = None

        self.minimum_value = None
        self.selling_restricted = None
        self.sell_blocked = False

        self.maximum_value = None
        self.buying_restricted = None
        self.buy_blocked = False

    @property
    def is_group(self):
        return self.ticker is None

    def restrict_selling(self, restrict=True):
        if self.is_group:
            apply_restriction(self.holdings, "selling_restricted", restrict)
        else:
            self.selling_restricted = restrict

        return self

    def restrict_buying(self, restrict=True):
        if self.is_group:
            apply_restriction(self.holdings, "buying_restricted", restrict)
        else:
            self.buying_restricted = restrict

        return self

    def change(self, shares, commission_spec: CommissionSpec):
        self.commission = self.commission_for(shares, commission_spec)
        self.shares = shares
        self.value = shares * self.price

    def commission_for(self, shares, commission_spec: CommissionSpec):
        return commission_spec.calculate(abs(shares - self.current_shares), self.price)


class Portfolio:
    def __init__(self, name, currency, commission_spec: CommissionSpec, *, holdings: List[Holding], free_assets):
        self.name = name
        self.currency = currency
        self.commission_spec = commission_spec
        self.holdings = holdings
        self.free_assets = Decimal(free_assets)

    def restrict_selling(self, restrict=True):
        apply_restriction(self.holdings, "selling_restricted", restrict)
        return self

    def restrict_buying(self, restrict=True):
        apply_restriction(self.holdings, "buying_restricted", restrict)
        return self


class Error(Exception):
    def __init__(self, *args):
        message, args = args[0], args[1:]
        super().__init__(message.format(*args) if args else message)


class LogicalError(Error):
    def __init__(self):
        super().__init__("Logical error.")


def apply_restriction(holdings: List[Holding], name, value):
    for holding in holdings:
        if holding.is_group:
            apply_restriction(holding.holdings, name, value)
        else:
            if not hasattr(holding, name):
                raise LogicalError()

            if getattr(holding, name) is None:
                setattr(holding, name, value)


def calculate(portfolio: Portfolio, *, fake_prices=False):
    tickers = set()

    def process(name, holdings: List[Holding]):
        if holdings and sum(holding.expected_weight for holding in holdings) != 1:
            raise Error("Invalid weights for {!r}.", name)

        for holding in holdings:
            if holding.is_group:
                process(holding.name, holding.holdings)
            else:
                tickers.add(holding.ticker)

    process(portfolio.name, portfolio.holdings)

    if fake_prices:
        prices = {ticker: Decimal(1) for ticker in tickers}
    else:
        # FIXME
        # prices = get_prices(tickers)
        prices = {'VXUS': Decimal('57.0200'), 'VGT': Decimal('180.8500'), 'MCHI': Decimal('69.1700'), 'BNDX': Decimal('54.3450'), 'IEMG': Decimal('55.8500'), 'VNQI': Decimal('60.7700'), 'VTI': Decimal('140.1950'), 'BND': Decimal('78.5250'), 'IAU': Decimal('12.3950')}
        prices.update({'FXCN': Decimal('2855'), 'FXIT': Decimal('4227'), 'FXRB': Decimal('1395'), 'FXRL': Decimal('2110'), 'FXUS': Decimal('2996')})

    current_value = calculate_current_value(portfolio.holdings, prices)
    total_value = current_value + portfolio.free_assets

    if not fake_prices:
        calculate_restrictions(portfolio.holdings)
        correct_weights_for_buying_restriction(portfolio.holdings, total_value)  # TODO: Display underuse?
        correct_weights_for_selling_restriction(portfolio.holdings, total_value)  # TODO: Display overuse?

    rebalanced_value = rebalance(portfolio.holdings, total_value, portfolio.commission_spec)
    commissions = calculate_total_commissions(portfolio.holdings)

    return rebalanced_value, total_value - rebalanced_value - commissions, commissions


def calculate_current_value(holdings: List[Holding], prices):
    total_value = Decimal()

    for holding in holdings:
        if holding.is_group:
            holding.value = holding.current_value = calculate_current_value(holding.holdings, prices)
        else:
            holding.price = prices[holding.ticker]
            holding.value = holding.current_value = holding.current_shares * holding.price

        total_value += holding.current_value

    return total_value


def calculate_restrictions(holdings: List[Holding]):
    total_minimum_value = None
    total_maximum_value = None

    maximum_values = []

    for holding in holdings:
        if holding.is_group:
            holding.minimum_value, holding.maximum_value = calculate_restrictions(holding.holdings)
        else:
            if holding.selling_restricted:
                holding.minimum_value = holding.current_value

            if holding.buying_restricted:
                holding.maximum_value = holding.current_value

        if holding.minimum_value is not None:
            if total_minimum_value is None:
                total_minimum_value = holding.minimum_value
            else:
                total_minimum_value += holding.minimum_value

        if holding.maximum_value is not None:
            maximum_values.append(holding.maximum_value)

    if len(maximum_values) == len(holdings):
        total_maximum_value = sum(holdings)

    return total_minimum_value, total_maximum_value


def correct_weights_for_selling_restriction(holdings: List[Holding], expected_total_value):
    while True:
        succeeded = True
        total_assets_overuse = Decimal()
        correctable_holdings = []

        for holding in holdings:
            expected_value = expected_total_value * holding.weight

            if holding.minimum_value is not None and expected_value <= holding.minimum_value:
                total_assets_overuse += holding.minimum_value - expected_value
            else:
                correctable_holdings.append(holding)

        if total_assets_overuse:
            if correctable_holdings:
                expected_value = Decimal()
                for holding in correctable_holdings:
                    expected_value += expected_total_value * holding.weight

                correction_multiplicator = (expected_value - total_assets_overuse) / expected_value

                for holding in correctable_holdings:
                    corrected_weight = holding.weight * correction_multiplicator

                    if (
                        holding.minimum_value is not None and
                        expected_total_value * corrected_weight < holding.minimum_value
                    ):
                        corrected_weight = holding.minimum_value / expected_total_value
                        succeeded = False

                    holding.weight = corrected_weight
            else:
                succeeded = False

        if not succeeded and correctable_holdings:
            continue

        for holding in holdings:
            if holding.is_group:
                succeeded &= correct_weights_for_selling_restriction(
                    holding.holdings, expected_total_value * holding.weight)

        return succeeded


def correct_weights_for_buying_restriction(holdings: List[Holding], expected_total_value):
    while True:
        succeeded = True
        extra_assets = Decimal()
        correctable_holdings = []

        for holding in holdings:
            expected_value = expected_total_value * holding.weight

            if holding.maximum_value is not None and expected_value >= holding.maximum_value:
                extra_assets += expected_value - holding.maximum_value
            else:
                correctable_holdings.append(holding)

        if extra_assets:
            if correctable_holdings:
                expected_value = Decimal()
                for holding in correctable_holdings:
                    expected_value += expected_total_value * holding.weight

                correction_multiplicator = (expected_value + extra_assets) / expected_value

                for holding in correctable_holdings:
                    corrected_weight = holding.weight * correction_multiplicator

                    if (
                        holding.maximum_value is not None and
                        expected_total_value * corrected_weight > holding.maximum_value
                    ):
                        corrected_weight = holding.maximum_value / expected_total_value
                        succeeded = False

                    holding.weight = corrected_weight
            else:
                succeeded = False

        if not succeeded and correctable_holdings:
            continue

        for holding in holdings:
            if holding.is_group:
                succeeded &= correct_weights_for_buying_restriction(
                    holding.holdings, expected_total_value * holding.weight)

        return succeeded


def rebalance(holdings: List[Holding], expected_total_value, commission_spec: CommissionSpec):
    total_value = Decimal()

    for holding in holdings:
        expected_value = expected_total_value * holding.weight

        if holding.is_group:
            holding.value = rebalance(holding.holdings, expected_value, commission_spec)
        else:
            if holding.shares != holding.current_shares:
                raise LogicalError()

            current_weight = get_weight(expected_total_value, holding.current_value)

            if current_weight != holding.weight:
                rebalanced_shares = expected_value // holding.price

                if rebalanced_shares != holding.current_shares:
                    commissions = holding.commission_for(rebalanced_shares, commission_spec)
                    rebalanced_shares = (expected_value - commissions) // holding.price

                if rebalanced_shares != holding.current_shares:
                    if rebalanced_shares < holding.current_shares and holding.selling_restricted:
                        holding.sell_blocked = True
                    elif rebalanced_shares > holding.current_shares and holding.buying_restricted:
                        holding.buy_blocked = True
                    else:
                        holding.change(rebalanced_shares, commission_spec)

        total_value += holding.value

    return total_value


def calculate_total_commissions(holdings: List[Holding]):
    commissions = 0

    for holding in holdings:
        if holding.is_group:
            commissions += calculate_total_commissions(holding.holdings)
        else:
            commissions += holding.commission

    return commissions

# FIXME
# def distribute_free_assets(holdings: List[Holding], expected_total_value, free_assets, commission_spec: CommissionSpec):
#     total_commissions = 0
#
#     for holding in sorted(holdings,
#         key=lambda holding: get_difference_from_expected(holding, expected_total_value * holding.weight),
#         reverse=True
#     ):
#         if free_assets <= 0:
#             return
#
#         expected_value = expected_total_value * holding.weight
#
#         if holding.is_group:
#             free_assets, commissions = distribute_free_assets(
#                 holding.holdings, expected_value, free_assets, commission_spec)
#             total_commissions += commissions
#         else:
#             if holding.rebalanced_shares is None:
#                 current_shares = holding.shares
#                 current_value = holding.value
#             else:
#                 current_shares = holding.rebalanced_shares
#                 current_value = holding.rebalanced_value
#
#             if current_value < expected_value:
#                 extra_shares = free_assets // holding.price
#
#                 if extra_shares > 0:
#                     commissions = commission_spec.calculate(extra_shares, holding.price)
#                     extra_shares = (free_assets - commissions) // holding.price
#
#                 if extra_shares > 0:
#                     holding.rebalanced_shares = current_shares + extra_shares
#                     holding.rebalanced_value = current_value + extra_shares * holding.price
#                     total_commissions += commission_spec.calculate(extra_shares, holding.price)
#
#     return free_assets, total_commissions
#
#
# def get_difference_from_expected(holding: Holding, expected_value):
#     current_value = holding.value if holding.rebalanced_value is None else holding.rebalanced_value
#     difference = (expected_value - current_value) / expected_value
#     return difference


def show(action, portfolio: Portfolio, holdings: List[Holding], expected_total_value, *, depth=0):
    for holding in sorted(holdings, key=operator.attrgetter("weight"), reverse=True):
        title = "{indent}* {name}".format(indent="  " * depth, name=holding.name)
        expected_value = expected_total_value * holding.weight

        if action != Actions.SHOW:
            if holding.sell_blocked:
                title += " [sell blocked]"

            if holding.buy_blocked:
                title += " [buy blocked]"

            title += " -"

            if not holding.is_group:
                title += " " + format_shares(holding.current_shares)

            current_weight = get_weight(expected_total_value, holding.current_value)
            title += " {current_weight} ({current_value})".format(
                current_weight=format_weight(current_weight),
                current_value=format_assets(holding.current_value, portfolio.currency))

            if holding.value != holding.current_value:
                if not holding.is_group:
                    title += " {shares_change} ({value_change})".format(
                        shares_change=format_shares(holding.shares - holding.current_shares, sign=True),
                        value_change=abs(holding.value - holding.current_value))

                title += " → {result_weight} ({result_value})".format(
                    result_weight=format_weight(get_weight(expected_total_value, holding.value)),
                    result_value=format_assets(holding.value, portfolio.currency))

        title += " {delimiter} {expected_weight} ({expected_value})".format(
            delimiter="-" if action == Actions.SHOW else "/",
            expected_weight=format_weight(holding.expected_weight),
            expected_value=format_assets(expected_total_value * holding.expected_weight, portfolio.currency))

        if holding.is_group:
            title += ":"

        print(title)
        if holding.is_group:
            show(action, portfolio, holding.holdings, expected_value, depth=depth + 1)


def get_weight(assets, value):
    if assets == 0:
        return Decimal(1)
    else:
        return value / assets


def format_shares(shares, sign=False):
    format_string = "{"
    if sign:
        format_string += ":+"
    format_string += "}s"
    return format_string.format(shares)


def format_assets(assets, currency):
    string = str(int(assets))

    if currency == Currency.USD:
        string = "$" + string
    elif currency == Currency.RUB:
        string += "₽"
    else:
        raise LogicalError()

    return string


def format_weight(weight):
    return ("{:.1f}".format(weight * 100).rstrip("0").rstrip(".") or "0") + "%"


def get_prices(tickers):
    prices = {}
    if not tickers:
        return prices

    response = requests.get("https://www.alphavantage.co/query", params={
        "function": "BATCH_STOCK_QUOTES",
        "symbols": ",".join(tickers),
        "apikey": "api-key-stub"
    })
    response.raise_for_status()
    result = response.json()

    if "Error Message" in result:
        raise Error("Unable to get tickers info: {}", result["Error Message"])

    for quote in result["Stock Quotes"]:
        prices[quote["1. symbol"]] = Decimal(quote["2. price"])

    unknown_tickers = set(tickers) - set(prices)
    if not unknown_tickers:
        return prices

    # See http://iss.moex.com/iss/reference/
    response = requests.get("https://iss.moex.com/iss/engines/stock/markets/shares/securities.json", params={
        "securities": ",".join(unknown_tickers),
    })
    response.raise_for_status()
    result = response.json()

    market_data = result["marketdata"]
    columns = market_data["columns"]
    ticker_column_id = columns.index("SECID")
    board_column_id = columns.index("BOARDID")
    price_column_id = columns.index("LAST")

    for data in market_data["data"]:
        ticker = data[ticker_column_id]
        if ticker in unknown_tickers and data[board_column_id] == "TQTF":
            prices[ticker] = Decimal(data[price_column_id])

    unknown_tickers = set(tickers) - set(prices)
    if unknown_tickers:
        raise Error("Unable to get info for the following tickers: {}.", ", ".join(unknown_tickers))

    return prices


def process_portfolio(action, portfolio: Portfolio):
    print(portfolio.name + ":")

    if action == Actions.SHOW:
        calculate(portfolio, fake_prices=True)
        show(action, portfolio, portfolio.holdings, portfolio.free_assets)
    else:
        total_value, free_assets, commissions = calculate(portfolio)
        show(action, portfolio, portfolio.holdings, total_value)

        print()
        print("Total value: " + format_assets(total_value, portfolio.currency))
        print("Free assets: " + format_assets(free_assets, portfolio.currency))
        print("Commissions: " + format_assets(commissions, portfolio.currency))


def parse_args():
    parser = argparse.ArgumentParser(description=__doc__)
    parser.add_argument("action", choices=Actions.ALL, help="action to process")
    return parser.parse_args()


def main():
    portfolios = [ ]
    args = parse_args()

    for portfolio_id, portfolio in enumerate(portfolios):
        if portfolio_id:
            print("\n")

        process_portfolio(args.action, portfolio)


if __name__ == "__main__":
    main()
