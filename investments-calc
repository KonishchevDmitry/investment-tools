#!/usr/bin/env python3

"""Investments distribution calculator"""

import argparse
import operator

from decimal import Decimal
from typing import List

import requests


class Actions:
    SHOW = "show"
    REBALANCE = "rebalance"

    ALL = [SHOW, REBALANCE]


class Currency:
    USD = "usd"
    RUB = "rub"


class Holding:
    def __init__(self, name, weight, ticker=None, shares=None, holdings=None):
        if ticker is None:
            if not holdings:
                raise Error("Invalid holding {!r}: ticker must be specified.", name)
        else:
            name = "{} ({})".format(name, ticker)

        if (ticker is None) != (shares is None):
            raise Error("Invalid holding {!r}: ticker must be specified with shares.", name)

        self.ticker = ticker
        self.name = name
        self.shares = shares
        self.expected_weight = Decimal(weight) / 100

        self.price = None
        self.value = None

        self.minimum_value = None
        self.selling_restricted = None
        self.sell_blocked = False

        self.maximum_value = None
        self.buying_restricted = None
        self.buy_blocked = False

        self.weight = self.expected_weight
        self.rebalanced_shares = None
        self.rebalanced_value = None

        self.holdings = holdings or []

    @property
    def is_group(self):
        return self.shares is None

    def restrict_selling(self, restrict=True):
        if self.is_group:
            apply_restriction(self.holdings, "selling_restricted", restrict)
        else:
            self.selling_restricted = restrict

        return self

    def restrict_buying(self, restrict=True):
        if self.is_group:
            apply_restriction(self.holdings, "buying_restricted", restrict)
        else:
            self.buying_restricted = restrict

        return self


class Portfolio:
    def __init__(self, name, currency, *, transaction_fee, holdings: List[Holding], free_assets):
        self.name = name
        self.currency = currency
        self.transaction_fee = Decimal(transaction_fee)
        self.holdings = holdings
        self.free_assets = Decimal(free_assets)

    def restrict_selling(self, restrict=True):
        apply_restriction(self.holdings, "selling_restricted", restrict)
        return self

    def restrict_buying(self, restrict=True):
        apply_restriction(self.holdings, "buying_restricted", restrict)
        return self


class Error(Exception):
    def __init__(self, *args):
        message, args = args[0], args[1:]
        super().__init__(message.format(*args) if args else message)


class LogicalError(Error):
    def __init__(self):
        super().__init__("Logical error.")


def apply_restriction(holdings: List[Holding], name, value):
    for holding in holdings:
        if holding.is_group:
            apply_restriction(holding.holdings, name, value)
        else:
            if not hasattr(holding, name):
                raise LogicalError()

            if getattr(holding, name) is None:
                setattr(holding, name, value)


def calculate(portfolio: Portfolio, *, fake_prices=False):
    tickers = set()

    def process(name, holdings: List[Holding]):
        if holdings and sum(holding.expected_weight for holding in holdings) != 1:
            raise Error("Invalid weights for {!r}.", name)

        for holding in holdings:
            if holding.ticker is not None:
                tickers.add(holding.ticker)

            process(holding.name, holding.holdings)

    process(portfolio.name, portfolio.holdings)

    if fake_prices:
        prices = {ticker: Decimal(1) for ticker in tickers}
    else:
        prices = get_prices(tickers)

    current_value = calculate_current_value(portfolio.holdings, prices)
    total_value = current_value + portfolio.free_assets

    if not fake_prices:
        calculate_restrictions(portfolio.holdings)
        correct_weights_for_buying_restriction(portfolio.holdings, total_value)  # TODO: Display underuse?
        correct_weights_for_selling_restriction(portfolio.holdings, total_value)  # TODO: Display overuse?

    rebalanced_value, commissions = rebalance(portfolio.holdings, total_value, portfolio.transaction_fee)

    return rebalanced_value, total_value - rebalanced_value - commissions, commissions


def calculate_current_value(holdings: List[Holding], prices):
    total_value = Decimal()

    for holding in holdings:
        if holding.is_group:
            holding.value = calculate_current_value(holding.holdings, prices)
        else:
            holding.price = prices[holding.ticker]
            holding.value = holding.shares * holding.price

        total_value += holding.value

    return total_value


def calculate_restrictions(holdings: List[Holding]):
    total_minimum_value = None
    total_maximum_value = None

    maximum_values = []

    for holding in holdings:
        if holding.is_group:
            holding.minimum_value, holding.maximum_value = calculate_restrictions(holding.holdings)
        else:
            if holding.selling_restricted:
                holding.minimum_value = holding.value

            if holding.buying_restricted:
                holding.maximum_value = holding.value

        if holding.minimum_value is not None:
            if total_minimum_value is None:
                total_minimum_value = holding.minimum_value
            else:
                total_minimum_value += holding.minimum_value

        if holding.maximum_value is not None:
            maximum_values.append(holding.maximum_value)

    if len(maximum_values) == len(holdings):
        total_maximum_value = sum(holdings)

    return total_minimum_value, total_maximum_value


def correct_weights_for_selling_restriction(holdings: List[Holding], expected_total_value):
    while True:
        succeeded = True
        total_assets_overuse = Decimal()
        correctable_holdings = []

        for holding in holdings:
            expected_value = expected_total_value * holding.weight

            if holding.minimum_value is not None and expected_value <= holding.minimum_value:
                total_assets_overuse += holding.minimum_value - expected_value
            else:
                correctable_holdings.append(holding)

        if total_assets_overuse:
            if correctable_holdings:
                expected_value = Decimal()
                for holding in correctable_holdings:
                    expected_value += expected_total_value * holding.weight

                correction_multiplicator = (expected_value - total_assets_overuse) / expected_value

                for holding in correctable_holdings:
                    corrected_weight = holding.weight * correction_multiplicator

                    if (
                        holding.minimum_value is not None and
                        expected_total_value * corrected_weight < holding.minimum_value
                    ):
                        corrected_weight = holding.minimum_value / expected_total_value
                        succeeded = False

                    holding.weight = corrected_weight
            else:
                succeeded = False

        if not succeeded and correctable_holdings:
            continue

        for holding in holdings:
            succeeded &= correct_weights_for_selling_restriction(
                holding.holdings, expected_total_value * holding.weight)

        return succeeded


def correct_weights_for_buying_restriction(holdings: List[Holding], expected_total_value):
    while True:
        succeeded = True
        extra_assets = Decimal()
        correctable_holdings = []

        for holding in holdings:
            expected_value = expected_total_value * holding.weight

            if holding.maximum_value is not None and expected_value >= holding.maximum_value:
                extra_assets += expected_value - holding.maximum_value
            else:
                correctable_holdings.append(holding)

        if extra_assets:
            if correctable_holdings:
                expected_value = Decimal()
                for holding in correctable_holdings:
                    expected_value += expected_total_value * holding.weight

                correction_multiplicator = (expected_value + extra_assets) / expected_value

                for holding in correctable_holdings:
                    corrected_weight = holding.weight * correction_multiplicator

                    if (
                        holding.maximum_value is not None and
                        expected_total_value * corrected_weight > holding.maximum_value
                    ):
                        corrected_weight = holding.maximum_value / expected_total_value
                        succeeded = False

                    holding.weight = corrected_weight
            else:
                succeeded = False

        if not succeeded and correctable_holdings:
            continue

        for holding in holdings:
            succeeded &= correct_weights_for_buying_restriction(
                holding.holdings, expected_total_value * holding.weight)

        return succeeded


def rebalance(holdings: List[Holding], expected_total_value, transaction_fee):
    total_rebalanced_value = Decimal()
    total_commissions = Decimal()

    for holding in holdings:
        if holding.is_group:
            rebalanced_value, commissions = rebalance(
                holding.holdings, expected_total_value * holding.weight, transaction_fee)

            if rebalanced_value != holding.value:
                holding.rebalanced_value = rebalanced_value

            total_commissions += commissions
        else:
            current_weight = get_weight(expected_total_value, holding.value)

            if current_weight != holding.weight:
                rebalanced_shares = expected_total_value * holding.weight // holding.price

                if rebalanced_shares != holding.shares:
                    if rebalanced_shares < holding.shares and holding.selling_restricted:
                        holding.sell_blocked = True
                    elif rebalanced_shares > holding.shares and holding.buying_restricted:
                        holding.buy_blocked = True
                    else:
                        holding.rebalanced_shares = rebalanced_shares
                        holding.rebalanced_value = holding.rebalanced_shares * holding.price
                        total_commissions += transaction_fee

        total_rebalanced_value += holding.value if holding.rebalanced_value is None else holding.rebalanced_value

    return total_rebalanced_value, total_commissions


def show(action, portfolio: Portfolio, holdings: List[Holding], expected_total_value, *, depth=0):
    for holding in sorted(holdings, key=operator.attrgetter("weight"), reverse=True):
        title = "{indent}* {name}".format(indent="  " * depth, name=holding.name)
        expected_value = expected_total_value * holding.weight

        if action != Actions.SHOW:
            if holding.sell_blocked:
                title += " [sell blocked]"

            if holding.buy_blocked:
                title += " [buy blocked]"

            title += " -"

            if not holding.is_group:
                title += " " + format_shares(holding.shares)

            current_weight = get_weight(expected_total_value, holding.value)
            title += " {weight} ({value})".format(
                weight=format_weight(current_weight), value=format_assets(holding.value, portfolio.currency))

            if holding.rebalanced_value is not None:
                if holding.rebalanced_shares is not None:
                    shares_change = holding.rebalanced_shares - holding.shares
                    title += " {shares} ({value})".format(
                        shares=format_shares(shares_change, sign=True),
                        value=abs(shares_change) * holding.price)

                rebalanced_weight = get_weight(expected_total_value, holding.rebalanced_value)
                title += " → {weight} ({value})".format(
                    weight=format_weight(rebalanced_weight),
                    value=format_assets(holding.rebalanced_value, portfolio.currency))

        title += " {delimiter} {weight} ({value})".format(
            delimiter="-" if action == Actions.SHOW else "/",
            weight=format_weight(holding.expected_weight),
            value=format_assets(expected_total_value * holding.expected_weight, portfolio.currency))

        if holding.holdings:
            title += ":"

        print(title)
        show(action, portfolio, holding.holdings, expected_value, depth=depth + 1)


def get_weight(assets, value):
    if value == 0:
        return Decimal(1)
    else:
        return value / assets


def format_shares(shares, sign=False):
    format_string = "{"
    if sign:
        format_string += ":+"
    format_string += "}Q"
    return format_string.format(shares)


def format_assets(assets, currency):
    string = str(int(assets))

    if currency == Currency.USD:
        string = "$" + string
    elif currency == Currency.RUB:
        string += "₽"
    else:
        raise LogicalError()

    return string


def format_weight(weight):
    return ("{:.1f}".format(weight * 100).rstrip("0").rstrip(".") or "0") + "%"


def get_prices(tickers):
    prices = {}
    if not tickers:
        return prices

    response = requests.get("https://www.alphavantage.co/query", params={
        "function": "BATCH_STOCK_QUOTES",
        "symbols": ",".join(tickers),
        "apikey": "api-key-stub"
    })
    response.raise_for_status()
    result = response.json()

    if "Error Message" in result:
        raise Error("Unable to get tickers info: {}", result["Error Message"])

    for quote in result["Stock Quotes"]:
        prices[quote["1. symbol"]] = Decimal(quote["2. price"])

    unknown_tickers = set(tickers) - set(prices)
    if not unknown_tickers:
        return prices

    # See http://iss.moex.com/iss/reference/
    response = requests.get("https://iss.moex.com/iss/engines/stock/markets/shares/securities.json", params={
        "securities": ",".join(unknown_tickers),
    })
    response.raise_for_status()
    result = response.json()

    market_data = result["marketdata"]
    columns = market_data["columns"]
    ticker_column_id = columns.index("SECID")
    board_column_id = columns.index("BOARDID")
    price_column_id = columns.index("LAST")

    for data in market_data["data"]:
        ticker = data[ticker_column_id]
        if ticker in unknown_tickers and data[board_column_id] == "TQTF":
            prices[ticker] = Decimal(data[price_column_id])

    unknown_tickers = set(tickers) - set(prices)
    if unknown_tickers:
        raise Error("Unable to get info for the following tickers: {}.", ", ".join(unknown_tickers))

    return prices


def process_portfolio(action, portfolio: Portfolio):
    print(portfolio.name + ":")

    if action == Actions.SHOW:
        calculate(portfolio, fake_prices=True)
        show(action, portfolio, portfolio.holdings, portfolio.free_assets)
    else:
        total_value, free_assets, commissions = calculate(portfolio)
        show(action, portfolio, portfolio.holdings, total_value)

        print()
        print("Total value: " + format_assets(total_value, portfolio.currency))
        print("Free assets: " + format_assets(free_assets, portfolio.currency))
        print("Commissions: " + format_assets(commissions, portfolio.currency))


def parse_args():
    parser = argparse.ArgumentParser(description=__doc__)
    parser.add_argument("action", choices=Actions.ALL, help="action to process")
    return parser.parse_args()


def main():
    portfolios = []
    args = parse_args()

    for portfolio_id, portfolio in enumerate(portfolios):
        if portfolio_id:
            print("\n")

        process_portfolio(args.action, portfolio)


if __name__ == "__main__":
    main()
